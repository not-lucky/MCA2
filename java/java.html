<!DOCTYPE html>
<html>
<head>
<title>java.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="java">Java</h1>
<h2 id="unit-1">Unit 1</h2>
<h3 id="class">Class</h3>
<ul>
<li>template / blueprint for creating obj (instance of class).</li>
<li>defines attributes and behaviours of obj.</li>
<li>Ex. Car:
<ul>
<li>attr: make, model, color, number of doors.</li>
<li>behaviour: starting of engine, accelerating, braking.</li>
</ul>
</li>
</ul>
<h3 id="object">Object</h3>
<ul>
<li>specific instance of a class</li>
<li>created from class</li>
<li>has its own set of values for attrs.</li>
<li>Ex: Toyota model, color blue, no. of doors 4.</li>
</ul>
<h3 id="evolution-of-java-byte-code-jdk-jvm-jre">Evolution of Java, Byte Code, JDK, JVM, JRE</h3>
<p>Here is an explanation in points for the evolution of Java, byte code, JDK, JVM, and JRE:</p>
<ol>
<li>
<p>In 1991, James Gosling and his team at Sun Microsystems started the development of a new programming language called Oak, which later became Java.</p>
</li>
<li>
<p>The first version of Java, called Java 1.0, was released in 1996.</p>
</li>
<li>
<p>Java introduced the concept of write once, run anywhere (WORA), which means that code written in Java can run on any platform that has a Java Virtual Machine (JVM) installed.</p>
</li>
<li>
<p>Java programs are compiled into bytecode, which is an intermediate language that can be executed by a JVM.</p>
</li>
<li>
<p>The JVM is a virtual machine that interprets the bytecode and executes it on the underlying operating system.</p>
</li>
<li>
<p>The Java Development Kit (JDK) is a software development kit that includes tools for developing, compiling, and debugging Java programs.</p>
</li>
<li>
<p>The JDK includes the Java Runtime Environment (JRE), which is a subset of the JDK and includes the JVM and essential libraries for running Java programs.</p>
</li>
<li>
<p>The JRE is installed on end-user machines to run Java applications.</p>
</li>
<li>
<p>As Java evolved, new versions were released, adding new features and improving performance.</p>
</li>
<li>
<p>In 2010, Oracle Corporation acquired Sun Microsystems and became the steward of the Java platform.</p>
</li>
<li>
<p>Today, Java is widely used for developing a variety of applications, including web applications, desktop applications, mobile applications, and enterprise software.</p>
</li>
</ol>
<h3 id="application-and-benefits-of-oops">Application and benefits of OOPs</h3>
<p>An application is a program or software that performs a specific task or set of tasks. Object-Oriented Programming (OOP) is a programming paradigm that revolves around the concept of objects, which are instances of classes that contain data and methods.</p>
<p>Some of the benefits of using OOP in software development include:</p>
<ol>
<li>
<p>Modularity: OOP allows you to break down complex systems into smaller, more manageable modules (objects) that can be reused in different parts of your application or in other applications altogether.</p>
</li>
<li>
<p>Encapsulation: By bundling data and behavior within a single object, OOP promotes encapsulation, which protects the data from outside interference and ensures that each object is responsible for its own behavior.</p>
</li>
<li>
<p>Inheritance: In OOP, classes can inherit properties and behavior from other classes. This enables developers to create new classes that extend or modify the behavior of existing classes, thereby reducing redundancy and improving code reuse.</p>
</li>
<li>
<p>Polymorphism: OOP supports polymorphism, which allows developers to create multiple implementations of the same method, each tailored to a specific class or situation. This can make your code more flexible and adaptable to changing requirements.</p>
</li>
<li>
<p>Abstraction: OOP promotes abstraction, which allows developers to focus on the essential characteristics of an object and ignore the details that are irrelevant to its behavior. This can make your code more understandable and maintainable.</p>
</li>
</ol>
<p>Overall, OOP provides a powerful set of tools for software development that can help you build more modular, reusable, and maintainable applications.</p>
<h3 id="encapsulation">Encapsulation</h3>
<p>Make sure that &quot;sensitive&quot; data is hidden from users.
To achieve this:
-   declare class variables/attributes as private.
-   provide public get and set methods to access and update the value of a private variable.</p>
<h3 id="inheritance">Inheritance</h3>
<ul>
<li>inherit attr. and methods from one class to another.</li>
<li>2 categories:
<ul>
<li>subclass (child)</li>
<li>superclass (parent)</li>
</ul>
</li>
<li>uses extends keyword</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> </span>{
  <span class="hljs-keyword">protected</span> String brand = <span class="hljs-string">"Ford"</span>;        <span class="hljs-comment">// Vehicle attribute</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">honk</span><span class="hljs-params">()</span> </span>{                    <span class="hljs-comment">// Vehicle method</span>
    System.out.println(<span class="hljs-string">"Tuut, tuut!"</span>);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vehicle</span> </span>{
  <span class="hljs-keyword">private</span> String modelName = <span class="hljs-string">"Mustang"</span>;    <span class="hljs-comment">// Car attribute</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{

    <span class="hljs-comment">// Create a myCar object</span>
    Car myCar = <span class="hljs-keyword">new</span> Car();

    <span class="hljs-comment">// Call the honk() method (from the Vehicle class) on the myCar object</span>
    myCar.honk();

    <span class="hljs-comment">// Display the value of the brand attribute (from the Vehicle class) and the value of the modelName from the Car class</span>
    System.out.println(myCar.brand + <span class="hljs-string">" "</span> + myCar.modelName);
  }
}
</div></code></pre>
<h4 id="multilevel-vs-multiple-inheritance">Multilevel vs multiple inheritance</h4>
<h5 id="multilevel">Multilevel</h5>
<ul>
<li>ability of a subclass to inherit from a superclass that itself inherits from another superclass.</li>
<li>each subclass only one direct superclass.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"The animal is eating."</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mammal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"The mammal is sleeping."</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mammal</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bark</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"The dog is barking."</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritanceExample</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Dog d = <span class="hljs-keyword">new</span> Dog();
        d.eat(); <span class="hljs-comment">// output: The animal is eating.</span>
        d.sleep(); <span class="hljs-comment">// output: The mammal is sleeping.</span>
        d.bark(); <span class="hljs-comment">// output: The dog is barking.</span>
    }
}
</div></code></pre>
<h5 id="multiple-inheritance">Multiple Inheritance</h5>
<ul>
<li>ability of a subclass to inherit from multiple superclasses.</li>
<li>subclass can inherit properties and methods from more than one superclass</li>
<li>not all programming languages support multiple inheritance, as it can lead to conflicts and ambiguity when two or more superclasses have the same method or property names.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Name: "</span> + name);
        System.out.println(<span class="hljs-string">"Age: "</span> + age);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> </span>{
    <span class="hljs-keyword">private</span> String department;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">(String department)</span> </span>{
        <span class="hljs-keyword">this</span>.department = department;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDepartment</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Department: "</span> + department);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManagerEmployee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span>, <span class="hljs-title">Manager</span> </span>{
    <span class="hljs-keyword">private</span> String title;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ManagerEmployee</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String department, String title)</span> </span>{
        <span class="hljs-keyword">super</span>(name, age);
        <span class="hljs-keyword">this</span>.department = department;
        <span class="hljs-keyword">this</span>.title = title;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printTitle</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Title: "</span> + title);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritanceExample</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ManagerEmployee me = <span class="hljs-keyword">new</span> ManagerEmployee(<span class="hljs-string">"John Doe"</span>, <span class="hljs-number">35</span>, <span class="hljs-string">"Sales"</span>, <span class="hljs-string">"Sales Manager"</span>);
        me.printInfo(); <span class="hljs-comment">// output: Name: John Doe Age: 35</span>
        me.printDepartment(); <span class="hljs-comment">// output: Department: Sales</span>
        me.printTitle(); <span class="hljs-comment">// output: Title: Sales Manager</span>
    }
}
</div></code></pre>
<h3 id="polymorphism">Polymorphism</h3>
<ul>
<li>&quot;many forms&quot;</li>
<li>uses <strong>inherited</strong> methods to perform diff. tasks.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">animalSound</span><span class="hljs-params">()</span> </span>{
    System.out.println(<span class="hljs-string">"The animal makes a sound"</span>);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">animalSound</span><span class="hljs-params">()</span> </span>{
    System.out.println(<span class="hljs-string">"The pig says: wee wee"</span>);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">animalSound</span><span class="hljs-params">()</span> </span>{
    System.out.println(<span class="hljs-string">"The dog says: bow wow"</span>);
  }
}
</div></code></pre>
<h4 id="runtime-vs-compiletime-polymorphism">Runtime vs Compiletime polymorphism</h4>
<ol>
<li>Runtime:</li>
</ol>
<ul>
<li>dynamic polymorphism</li>
<li>overriding</li>
<li>decision about which implementation of the method to execute is made at runtime, based on actual object.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"The animal makes a sound."</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"The dog barks."</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"The cat meows."</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PolymorphismExample</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Animal a1 = <span class="hljs-keyword">new</span> Animal();
        Animal a2 = <span class="hljs-keyword">new</span> Dog();
        Animal a3 = <span class="hljs-keyword">new</span> Cat();
        
        a1.makeSound(); <span class="hljs-comment">// output: The animal makes a sound.</span>
        a2.makeSound(); <span class="hljs-comment">// output: The dog barks.</span>
        a3.makeSound(); <span class="hljs-comment">// output: The cat meows.</span>
    }
}
</div></code></pre>
<ol>
<li>Compiletime:</li>
</ol>
<ul>
<li>static polymorphism</li>
<li>method overloading</li>
<li>compiler decides which implementation of a method to execute at compile time, based on the number and types of arguments that are passed to the method.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
        <span class="hljs-keyword">return</span> a + b;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span> </span>{
        <span class="hljs-keyword">return</span> a + b;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">(String a, String b)</span> </span>{
        <span class="hljs-keyword">return</span> a + b;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PolymorphismExample</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Calculator calc = <span class="hljs-keyword">new</span> Calculator();
        <span class="hljs-keyword">int</span> sum1 = calc.add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// calls add(int a, int b)</span>
        <span class="hljs-keyword">double</span> sum2 = calc.add(<span class="hljs-number">2.5</span>, <span class="hljs-number">3.5</span>); <span class="hljs-comment">// calls add(double a, double b)</span>
        String sum3 = calc.add(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">" world!"</span>); <span class="hljs-comment">// calls add(String a, String b)</span>
        System.out.println(sum1); <span class="hljs-comment">// output: 5</span>
        System.out.println(sum2); <span class="hljs-comment">// output: 6.0</span>
        System.out.println(sum3); <span class="hljs-comment">// output: Hello world!</span>
    }
}
</div></code></pre>
<h3 id="variables">Variables</h3>
<ul>
<li>Local Variables:
<ul>
<li>declared inside a method, constructor, or block</li>
<li>can only be accessed within that scope</li>
<li>created when the method is called and destroyed when the method returns</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exampleMethod</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// local variable</span>
   System.out.println(x);
}
</div></code></pre>
<ul>
<li>instance variable
<ul>
<li>declared within a class but outside of any method</li>
<li>created when an object of the class is created</li>
<li>accessed by any method within the class and have a separate value for each object of the class</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleClass</span> </span>{
   <span class="hljs-keyword">int</span> y; <span class="hljs-comment">// instance variable</span>

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span> </span>{
      y = newValue;
   }

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printY</span><span class="hljs-params">()</span> </span>{
      System.out.println(y);
   }
}
</div></code></pre>
<ul>
<li>class variable
<ul>
<li>static variables</li>
<li>declared within a class but outside of any method (same as instance var)</li>
<li>BUT shared by all objects of the class</li>
<li>accessed by any method within the class and can also be accessed directly using the class name</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleClass</span> </span>{
   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> z; <span class="hljs-comment">// class variable</span>

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setZ</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span> </span>{
      z = newValue;
   }

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printZ</span><span class="hljs-params">()</span> </span>{
      System.out.println(z);
   }
}
</div></code></pre>
<h3 id="contructor-chaining">Contructor chaining</h3>
<ul>
<li>avoid duplicating the code in the constructors and make the code more concise and maintainable</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>(<span class="hljs-string">"Unknown"</span>, <span class="hljs-number">0</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>(name, <span class="hljs-number">0</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>(<span class="hljs-string">"Unknown"</span>, age);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }
}
</div></code></pre>
<h3 id="this-and-super">this and super</h3>
<ul>
<li>keywords used to refer to different objects.</li>
<li><code>this</code> refers to the current object, or the object that is executing the current method. It is often used to differentiate between instance variables and local variables with the same name.</li>
<li><code>super</code> refers to the parent class of the current class. It is often used to call methods or access instance variables defined in the parent class.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name; <span class="hljs-comment">// "this" refers to the instance variable "name"</span>
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> grade;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> grade)</span> </span>{
        <span class="hljs-keyword">super</span>(name); <span class="hljs-comment">// call the constructor of the parent class with the "name" parameter</span>
        <span class="hljs-keyword">this</span>.grade = grade;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.display(); <span class="hljs-comment">// call the "display" method of the parent class</span>
        System.out.println(<span class="hljs-string">"Grade: "</span> + grade);
    }
}
</div></code></pre>
<h3 id="abstract-class-in-java-in-points">Abstract class in java in points</h3>
<p>Here are some points about abstract class in Java:</p>
<ol>
<li>
<p>Abstract class is a class that contains at least one abstract method, which is declared but not defined in the abstract class.</p>
</li>
<li>
<p>An abstract class can contain both abstract and non-abstract (concrete) methods.</p>
</li>
<li>
<p>Abstract classes can have constructors and instance variables.</p>
</li>
<li>
<p>Abstract classes cannot be instantiated; they can only be subclassed (i.e., extended) to create concrete classes.</p>
</li>
<li>
<p>Subclasses of an abstract class must either provide an implementation for all the abstract methods in the superclass or themselves be declared as abstract.</p>
</li>
<li>
<p>Abstract classes can be used to define a common interface or set of methods for a group of related classes.</p>
</li>
<li>
<p>Abstract classes are useful for providing a base implementation that can be customized by subclasses.</p>
</li>
<li>
<p>Abstract classes are often used in template method design pattern.</p>
</li>
<li>
<p>Abstract classes can be used to implement interfaces partially.</p>
</li>
<li>
<p>Java allows a class to extend only one abstract class but it can implement multiple interfaces.</p>
</li>
</ol>
<h3 id="abstract-example">abstract example</h3>
<p>Sure, here's an example of an abstract class in Java and how to extend it:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// abstract class</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>{
  <span class="hljs-comment">// abstract method</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-comment">// concrete subclass extending Shape</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> length;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> width;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length, <span class="hljs-keyword">double</span> width)</span> </span>{
    <span class="hljs-keyword">this</span>.length = length;
    <span class="hljs-keyword">this</span>.width = width;
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> length * width;
  }
}

<span class="hljs-comment">// usage</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    Shape shape = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">5.0</span>, <span class="hljs-number">3.0</span>);
    System.out.println(<span class="hljs-string">"Area of rectangle: "</span> + shape.getArea());
  }
}
</div></code></pre>
<p>In this example, <code>Shape</code> is an abstract class with an abstract method <code>getArea()</code>. <code>Rectangle</code> is a concrete subclass of <code>Shape</code> that implements <code>getArea()</code> to return the area of the rectangle.</p>
<p>In the <code>main</code> method, we create a new <code>Rectangle</code> object with a length of 5.0 and a width of 3.0 and assign it to a variable of type <code>Shape</code>. We can then call the <code>getArea()</code> method on the <code>Shape</code> object, which actually invokes the implementation in the <code>Rectangle</code> subclass and returns the area of the rectangle.</p>
<h3 id="invalid-combo">Invalid combo</h3>
<ul>
<li>final abstract</li>
<li>private abstract</li>
<li>static abstract</li>
</ul>
<h3 id="interface">interface</h3>
<p>An interface in Java is a collection of abstract methods and constants. Here are some key points regarding interfaces in Java:</p>
<ol>
<li>
<p>An interface is declared using the <code>interface</code> keyword.</p>
</li>
<li>
<p>An interface can contain only abstract methods, static and default methods, and constants.</p>
</li>
<li>
<p>An interface cannot have any constructors.</p>
</li>
<li>
<p>All the methods declared in an interface are by default public and abstract.</p>
</li>
<li>
<p>An interface can be implemented by a class using the <code>implements</code> keyword.</p>
</li>
<li>
<p>A class can implement multiple interfaces.</p>
</li>
<li>
<p>Implementing an interface is a way to achieve multiple inheritances in Java.</p>
</li>
<li>
<p>An interface can also extend another interface using the <code>extends</code> keyword.</p>
</li>
<li>
<p>A class implementing an interface must implement all the methods declared in that interface.</p>
</li>
<li>
<p>An interface is used to provide a common behavior to unrelated classes.</p>
</li>
<li>
<p>The primary use of interfaces in Java is to implement abstraction.</p>
</li>
<li>
<p>Interfaces provide a way to achieve loose coupling between objects.</p>
</li>
<li>
<p>An interface can be used to define a contract that a class must follow in order to be used in a particular way.</p>
</li>
<li>
<p>Interfaces can be used to define a set of related methods that can be implemented by different classes in different ways, providing polymorphism.</p>
</li>
<li>
<p>The use of interfaces in Java makes it easy to replace or modify the implementation of a class without affecting the code that uses it.</p>
</li>
</ol>
<h3 id="interface-stuff">interface stuff</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uwu</span><span class="hljs-params">()</span></span>;
}
</div></code></pre>
<p>javap Car</p>
<pre class="hljs"><code><div>Compiled from <span class="hljs-string">"Car.java"</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>{
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uwu</span><span class="hljs-params">()</span></span>;
}
</div></code></pre>
<h3 id="multiple-inhereitance-via-interface-with-example">Multiple inhereitance via interface with example</h3>
<p>In Java, multiple inheritance is not allowed through classes. However, multiple inheritance can be achieved through interfaces. An interface can extend multiple interfaces, allowing a class that implements the interface to inherit from all the extended interfaces.</p>
<p>Here's an example of multiple inheritance using interfaces in Java:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceA</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceB</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InterfaceA</span>, <span class="hljs-title">InterfaceB</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">methodC</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InterfaceC</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Method A"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Method B"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodC</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Method C"</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        MyClass obj = <span class="hljs-keyword">new</span> MyClass();
        obj.methodA();
        obj.methodB();
        obj.methodC();
    }
}
</div></code></pre>
<p>In the above example, we have three interfaces - <code>InterfaceA</code>, <code>InterfaceB</code>, and <code>InterfaceC</code>. <code>InterfaceC</code> extends both <code>InterfaceA</code> and <code>InterfaceB</code>. The <code>MyClass</code> class implements <code>InterfaceC</code> and provides the implementation for all three methods - <code>methodA()</code>, <code>methodB()</code>, and <code>methodC()</code>.</p>
<p>When we run the program, it will output:</p>
<pre class="hljs"><code><div>Method A
Method B
Method C
</div></code></pre>
<p>This shows that we have successfully achieved multiple inheritance through interfaces.</p>
<h3 id="extends-vs-implements">extends vs implements</h3>
<p>In Java, <code>extends</code> and <code>implements</code> are both keywords used to define inheritance, but they are used in different contexts.</p>
<p><code>extends</code> is used to define inheritance between classes. When one class <code>extends</code> another class, it inherits all the non-private properties and methods of the superclass. The subclass can also add new properties and methods, and override the methods of the superclass. Example:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Eating..."</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bark</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Woof!"</span>);
    }
}

Dog dog = <span class="hljs-keyword">new</span> Dog();
dog.eat();  <span class="hljs-comment">// Output: Eating...</span>
dog.bark(); <span class="hljs-comment">// Output: Woof!</span>
</div></code></pre>
<p><code>implements</code> is used to define inheritance between a class and an interface. When a class <code>implements</code> an interface, it must provide an implementation for all the methods defined in the interface. Example:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Vehicle</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drive</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Vehicle</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drive</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Driving a car..."</span>);
    }
}

Car car = <span class="hljs-keyword">new</span> Car();
car.drive(); <span class="hljs-comment">// Output: Driving a car...</span>
</div></code></pre>
<p>In summary, <code>extends</code> is used for inheritance between classes, while <code>implements</code> is used for inheritance between a class and an interface.</p>
<h3 id="explain-anonymous-class--also-give-example">explain anonymous class , also give example.</h3>
<p>In Java, an anonymous class is a local class without a name. It is used when you need to create a class that will only be used once and you don't want to create a separate class for it. Anonymous classes are created and instantiated at the same time.</p>
<p>Here is an example of an anonymous class:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
       
       <span class="hljs-comment">// Creating an instance of an anonymous class that implements Runnable interface</span>
       Runnable r = <span class="hljs-keyword">new</span> Runnable() {
           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
               System.out.println(<span class="hljs-string">"Hello from anonymous class!"</span>);
           }
       };
       
       <span class="hljs-comment">// Starting the thread</span>
       Thread t = <span class="hljs-keyword">new</span> Thread(r);
       t.start();
   }
}
</div></code></pre>
<p>In this example, we create an anonymous class that implements the Runnable interface. We override the <code>run()</code> method to print a message. We then create a Thread object and pass the anonymous class as a parameter. We then start the thread to execute the <code>run()</code> method, which will print the message &quot;Hello from anonymous class!&quot; to the console.</p>
<h3 id="upcasting-and-downcasting">Upcasting and downcasting</h3>
<p>In Java, upcasting and downcasting are used to convert between related reference types. Upcasting is converting a reference of a subclass type to a reference of a superclass type, while downcasting is converting a reference of a superclass type to a reference of a subclass type. Here's an example to illustrate both upcasting and downcasting:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
    System.out.println(<span class="hljs-string">"Animal is eating."</span>);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bark</span><span class="hljs-params">()</span> </span>{
    System.out.println(<span class="hljs-string">"Dog is barking."</span>);
  }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    <span class="hljs-comment">// upcasting</span>
    Animal animal = <span class="hljs-keyword">new</span> Dog();
    animal.eat(); <span class="hljs-comment">// output: Animal is eating.</span>
    <span class="hljs-comment">// animal.bark(); // error: bark() method is not available on Animal type</span>

    <span class="hljs-comment">// downcasting</span>
    Dog dog = (Dog) animal;
    dog.bark(); <span class="hljs-comment">// output: Dog is barking.</span>
  }
}
</div></code></pre>
<p>In this example, <code>Animal</code> is a superclass of <code>Dog</code>. <code>Dog</code> inherits the <code>eat()</code> method from <code>Animal</code> and adds its own method <code>bark()</code>. In the <code>main</code> method, we create a new <code>Dog</code> object and assign it to a variable of type <code>Animal</code>. This is an example of upcasting, where a subclass object is assigned to a variable of its superclass type.</p>
<p>Even though the object is of type <code>Dog</code>, we can only access the methods and variables of the <code>Animal</code> class using the <code>animal</code> reference. In this case, we can call the <code>eat()</code> method, but not the <code>bark()</code> method because <code>animal</code> is of type <code>Animal</code>.</p>
<p>Next, we perform downcasting by casting the <code>animal</code> reference to <code>Dog</code> type using <code>(Dog) animal</code>. This is possible because we know that <code>animal</code> is actually referencing a <code>Dog</code> object. Now, we can use the <code>dog</code> reference to access the <code>bark()</code> method.</p>
<p>It's important to note that downcasting can be unsafe if the object being casted is not actually an instance of the target subclass type. In such cases, a <code>ClassCastException</code> will be thrown at runtime. To prevent this, it's recommended to use the <code>instanceof</code> operator to check the object's type before performing downcasting.</p>
<h3 id="array">Array</h3>
<p>Here are some key points about arrays in Java:</p>
<ol>
<li>An array is a collection of elements of the same data type.</li>
<li>Arrays have a fixed length that is defined when they are created.</li>
<li>The elements of an array are stored in contiguous memory locations.</li>
<li>Arrays are objects in Java and are dynamically allocated on the heap.</li>
<li>Elements of an array can be accessed using an index, starting at 0 for the first element.</li>
<li>Java supports multidimensional arrays, where each element is itself an array.</li>
<li>Java arrays can be initialized with values at the time of creation or can be assigned values later.</li>
<li>The length of an array can be obtained using the <code>length</code> field.</li>
<li>Java provides various methods to manipulate arrays such as sorting, searching, and copying.</li>
<li>Arrays in Java are passed by reference, meaning a reference to the array is passed to a method instead of a copy of the array.</li>
</ol>
<p>Overall, arrays are a fundamental data structure in Java that provide a convenient way to store and manipulate collections of elements.</p>
<h3 id="array-stuff">array stuff</h3>
<h2 id="java-wrapper-class-in-points-with-example">java wrapper class in points with example</h2>
<p>Wrapper classes in Java are used to represent primitive data types as objects. They provide a way to use primitive data types as objects, and they also provide utility methods to perform certain operations on these objects.</p>
<p>Some of the commonly used wrapper classes in Java are:</p>
<ol>
<li>Integer: used to wrap int values</li>
<li>Double: used to wrap double values</li>
<li>Character: used to wrap char values</li>
<li>Boolean: used to wrap boolean values</li>
</ol>
<p>Example:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Wrapping an int value in an Integer object</span>
Integer num = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);

<span class="hljs-comment">// Using utility methods of Integer class</span>
System.out.println(num.intValue()); <span class="hljs-comment">// prints 10</span>
System.out.println(Integer.parseInt(<span class="hljs-string">"20"</span>)); <span class="hljs-comment">// prints 20</span>

<span class="hljs-comment">// Unwrapping Integer object to int value</span>
<span class="hljs-keyword">int</span> x = num.intValue();
</div></code></pre>
<p>In the above example, we are creating an Integer object to wrap an int value, and then using the <code>intValue()</code> method to get the int value back. We are also using the <code>parseInt()</code> method of the Integer class to convert a String to an int value.</p>
<h2 id="string-buffer">string buffer</h2>
<p>StringBuffer in Java is a class that provides a mutable sequence of characters. It is similar to the String class, but unlike Strings, StringBuffers can be modified. StringBuffer is thread-safe which means multiple threads cannot access it simultaneously. Here are some important points about StringBuffer:</p>
<ol>
<li>StringBuffer is a mutable sequence of characters.</li>
<li>It is similar to the String class, but unlike Strings, StringBuffer can be modified.</li>
<li>StringBuffer is thread-safe which means multiple threads cannot access it simultaneously.</li>
<li>StringBuffer provides methods to append, insert, delete, and replace characters.</li>
<li>StringBuffer is efficient when it comes to modifying a string, especially when compared to creating a new string object.</li>
<li>StringBuffer is used when you need to modify strings frequently or when you are dealing with large strings.</li>
</ol>
<p>Here is an example of how to use StringBuffer to modify a string:</p>
<pre class="hljs"><code><div>StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">"Hello"</span>);
sb.append(<span class="hljs-string">" World"</span>);
System.out.println(sb.toString()); <span class="hljs-comment">// Output: "Hello World"</span>
sb.insert(<span class="hljs-number">6</span>, <span class="hljs-string">", "</span>);
System.out.println(sb.toString()); <span class="hljs-comment">// Output: "Hello, World"</span>
sb.delete(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>);
System.out.println(sb.toString()); <span class="hljs-comment">// Output: "HelloWorld"</span>
sb.replace(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-string">" everyone"</span>);
System.out.println(sb.toString()); <span class="hljs-comment">// Output: "Hello everyone"</span>
</div></code></pre>
<h2 id="import-in-java">import in java</h2>
<p>In Java, <code>import</code> is a keyword used to import a package or a specific class into the current file or scope, allowing access to its public members (fields, methods, and nested classes).</p>
<p>Here are some key points about <code>import</code> in Java:</p>
<ul>
<li><code>import</code> statements are placed at the top of the Java file, after the package declaration (if any) and before the class declaration.</li>
<li>They specify the fully qualified name of the package or class to be imported, and can include wildcards (<code>*</code>) to import all public members of a package or subpackage.</li>
<li>Multiple <code>import</code> statements can be included in a file to import from multiple packages or classes.</li>
<li>If the imported class or package name conflicts with a class or package in the current scope, the imported name can be aliased using the <code>as</code> keyword.</li>
</ul>
<p>Here is an example of importing a class in Java:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.ArrayList;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ArrayList&lt;String&gt; myList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-comment">// Do something with the ArrayList...</span>
    }
}
</div></code></pre>
<p>In this example, the <code>ArrayList</code> class from the <code>java.util</code> package is imported using the <code>import</code> statement, which allows it to be used directly in the code without the need for a fully qualified name.</p>
<h2 id="static-import-in-java">static import in java</h2>
<p>In Java, the <code>import</code> statement is used to bring a class or a package into scope so that it can be used in the current program. The <code>static import</code> statement is a variant of the <code>import</code> statement that allows static members of a class to be imported directly into the current class without using the class name.</p>
<p>When you use <code>static import</code>, you can access the static members of a class directly without qualifying them with the class name. This makes the code more concise and readable.</p>
<p>Here is an example of using <code>static import</code> to access the <code>PI</code> constant of the <code>Math</code> class directly:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.PI;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>{
      <span class="hljs-keyword">return</span> PI * radius * radius;
   }
}
</div></code></pre>
<p>In this example, we have imported the <code>PI</code> constant of the <code>Math</code> class using the <code>static import</code> statement. This allows us to use <code>PI</code> directly in the <code>getArea</code> method of the <code>Circle</code> class without qualifying it with the class name <code>Math</code>.</p>
<h2 id="explain-package-in-java-in-points-with-example">explain package in java in points with example</h2>
<p>Packages in Java are a way of organizing related classes and interfaces together. It provides a mechanism for grouping related classes/interfaces, which makes it easier to locate and use them. Here are some points that explain packages in Java:</p>
<ol>
<li>
<p>Packages in Java help to avoid naming conflicts that may occur when we have multiple classes with the same name.</p>
</li>
<li>
<p>Packages are hierarchical in nature, i.e., they can have sub-packages within them.</p>
</li>
<li>
<p>The primary use of packages is to group related classes/interfaces and provide access protection.</p>
</li>
<li>
<p>The access modifiers in Java (public, protected, private) can be used with packages to control the visibility of classes/interfaces within the package.</p>
</li>
<li>
<p>Packages can be imported using the &quot;import&quot; keyword in Java. This helps to avoid fully qualified class names in the code.</p>
</li>
<li>
<p>A package is declared using the &quot;package&quot; keyword in Java.</p>
</li>
</ol>
<p>Example:</p>
<p>Consider a scenario where we have multiple classes that deal with database operations. We can group all of these classes into a package named &quot;com.example.db&quot;. Here, &quot;com&quot; represents the organization that created this package, &quot;example&quot; represents the project name, and &quot;db&quot; represents the purpose of the package.</p>
<p>To declare a package, we can use the following statement at the beginning of each class:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.example.db;
</div></code></pre>
<p>To use a class from this package in another class, we can import it using the &quot;import&quot; statement:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> com.example.db.MyClass;
</div></code></pre>
<p>Here, &quot;MyClass&quot; is a class defined in the &quot;com.example.db&quot; package.</p>
<h3 id="exception-handling">exception handling</h3>
<ul>
<li>use throw for custom exception</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>{
    <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException(<span class="hljs-string">"Access denied - You must be at least 18 years old."</span>);
    }
    <span class="hljs-keyword">else</span> {
      System.out.println(<span class="hljs-string">"Access granted - You are old enough!"</span>);
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    checkAge(<span class="hljs-number">15</span>); <span class="hljs-comment">// Set age to 15 (which is below 18...)</span>
  }
}
</div></code></pre>
<h3 id="exceptions">exceptions</h3>
<h4 id="checked-and-unchecked-exceptions">checked and unchecked exceptions</h4>
<p>In Java, exceptions are used to handle errors or exceptional situations that may occur during program execution. There are two types of exceptions in Java: checked and unchecked exceptions.</p>
<ol>
<li>
<p>Checked exceptions:
Checked exceptions are the exceptions that are checked by the compiler at the compile-time. If a method throws a checked exception, then the calling method is required to handle it, either by catching it or by declaring it in its throws clause. Some examples of checked exceptions in Java are IOException, ClassNotFoundException, and SQLException.</p>
</li>
<li>
<p>Unchecked exceptions:
Unchecked exceptions are the exceptions that are not checked by the compiler at the compile-time. They are thrown at runtime when an exceptional situation occurs. Unlike checked exceptions, the calling method is not required to handle unchecked exceptions. Some examples of unchecked exceptions in Java are NullPointerException, ArrayIndexOutOfBoundsException, and ArithmeticException.</p>
</li>
</ol>
<p>It is a good practice to use checked exceptions for recoverable errors, such as input/output errors or database errors, and unchecked exceptions for unrecoverable errors, such as programming errors or runtime errors.</p>
<p>Here is an example of how to handle checked and unchecked exceptions in Java:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.io.FileNotFoundException;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionExample</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-comment">// Example of a checked exception (FileNotFoundException)</span>
        <span class="hljs-keyword">try</span> {
            File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"input.txt"</span>);
            Scanner scanner = <span class="hljs-keyword">new</span> Scanner(file);
            <span class="hljs-keyword">while</span> (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                System.out.println(line);
            }
            scanner.close();
        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
            System.out.println(<span class="hljs-string">"File not found."</span>);
            e.printStackTrace();
        }
        
        <span class="hljs-comment">// Example of an unchecked exception (ArithmeticException)</span>
        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
        <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">int</span> result = a / b;
            System.out.println(result);
        } <span class="hljs-keyword">catch</span> (ArithmeticException e) {
            System.out.println(<span class="hljs-string">"Divide by zero error."</span>);
            e.printStackTrace();
        }
    }
}
</div></code></pre>
<p>In this example, we handle a checked exception (FileNotFoundException) by catching it and printing the error message using the printStackTrace() method. We also handle an unchecked exception (ArithmeticException) by catching it and printing the error message.</p>
<h5 id="list-runtime-and-compiletime-exceptions">list runtime and compiletime exceptions</h5>
<p>In Java, there are two types of exceptions: checked exceptions and unchecked exceptions.</p>
<p><strong>Checked Exceptions</strong>
Checked exceptions are the exceptions that are checked at compile-time by the compiler. They occur during the execution of the program and may be recoverable. Some of the common checked exceptions are:</p>
<ul>
<li>IOException</li>
<li>SQLException</li>
<li>ClassNotFoundException</li>
<li>InvocationTargetException</li>
<li>ParseException</li>
</ul>
<p><strong>Unchecked Exceptions</strong>
Unchecked exceptions are the exceptions that are not checked at compile-time by the compiler. They occur during the execution of the program and are usually caused by programming errors or bugs. Some of the common unchecked exceptions are:</p>
<ul>
<li>NullPointerException</li>
<li>ArrayIndexOutOfBoundsException</li>
<li>ClassCastException</li>
<li>IllegalArgumentException</li>
<li>ArithmeticException</li>
</ul>
<p>It is important to handle exceptions properly in order to avoid unexpected crashes or behavior of the program.</p>
<h3 id="explain-object-class-in-java-in-points-with-example">explain Object class in java in points with example</h3>
<p>Sure, here are the key points about the Object class in Java with an example:</p>
<ol>
<li>Object class is the root class of all Java classes and is located in the java.lang package.</li>
<li>Every class in Java implicitly extends the Object class.</li>
<li>Object class has several methods like toString(), equals(), hashCode(), etc., which are inherited by all Java classes.</li>
<li>The toString() method returns a string representation of the object and is used to print the object.</li>
<li>The equals() method compares two objects for equality and returns a boolean value.</li>
<li>The hashCode() method returns an integer hash code value for the object.</li>
<li>Here's an example of how the Object class is implicitly used in Java:</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>{
        <span class="hljs-keyword">this</span>.id = id;
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-comment">// getters and setters</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Employee [id="</span> + id + <span class="hljs-string">", name="</span> + name + <span class="hljs-string">"]"</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == obj)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (getClass() != obj.getClass())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        Employee other = (Employee) obj;
        <span class="hljs-keyword">if</span> (id != other.id)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (other.name != <span class="hljs-keyword">null</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!name.equals(other.name))
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> prime = <span class="hljs-number">31</span>;
        <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;
        result = prime * result + id;
        result = prime * result + ((name == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : name.hashCode());
        <span class="hljs-keyword">return</span> result;
    }
}
</div></code></pre>
<p>In the above example, the Employee class implicitly extends the Object class, and it overrides the toString(), equals(), and hashCode() methods.</p>
<h3 id="array-copy-java">array copy java</h3>
<p>In Java, you can use the <code>System.arraycopy()</code> method to copy an array. This method allows you to copy a range of elements from one array to another array.</p>
<p>The syntax of the <code>System.arraycopy()</code> method is as follows:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arraycopy</span><span class="hljs-params">(Object src, <span class="hljs-keyword">int</span> srcPos, Object dest, <span class="hljs-keyword">int</span> destPos, <span class="hljs-keyword">int</span> length)</span>
</span></div></code></pre>
<ul>
<li><code>src</code>: The source array.</li>
<li><code>srcPos</code>: The starting position in the source array.</li>
<li><code>dest</code>: The destination array.</li>
<li><code>destPos</code>: The starting position in the destination array.</li>
<li><code>length</code>: The number of elements to copy.</li>
</ul>
<p>Here is an example program that demonstrates how to use the <code>System.arraycopy()</code> method:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayCopyExample</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] source = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
        <span class="hljs-keyword">int</span>[] destination = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];

        System.arraycopy(source, <span class="hljs-number">0</span>, destination, <span class="hljs-number">0</span>, source.length);

        <span class="hljs-comment">// Print the elements of the destination array</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; destination.length; i++) {
            System.out.print(destination[i] + <span class="hljs-string">" "</span>);
        }
    }
}
</div></code></pre>
<p>In this example, we create a source array <code>source</code> with five elements and a destination array <code>destination</code> with the same size. We then use the <code>System.arraycopy()</code> method to copy the entire <code>source</code> array to the <code>destination</code> array. Finally, we print the elements of the <code>destination</code> array to verify that the copy was successful.</p>
<h3 id="boxing-and-autoboxing">boxing and autoboxing</h3>
<p>Boxing is the process of converting a primitive data type to its corresponding object wrapper class, and autoboxing is the automatic conversion of primitive data types to their corresponding object wrapper classes by the Java compiler.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Boxing</span>
<span class="hljs-keyword">double</span> d = <span class="hljs-number">3.14</span>;
Double dObj = Double.valueOf(d);

<span class="hljs-comment">// Autoboxing</span>
<span class="hljs-keyword">char</span> c = <span class="hljs-string">'A'</span>;
Character cObj = c;

<span class="hljs-comment">// Unboxing</span>
Long longObj = Long.valueOf(<span class="hljs-number">123456789</span>);
<span class="hljs-keyword">long</span> l = longObj.longValue();

<span class="hljs-comment">// Autounboxing</span>
Boolean boolObj = Boolean.valueOf(<span class="hljs-keyword">true</span>);
<span class="hljs-keyword">boolean</span> bool = boolObj;
</div></code></pre>

</body>
</html>
